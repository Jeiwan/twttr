(ns twttr.middleware
  (:require [clojure.string :as str]
            [clojure.data.json :as json]
            [clojure.java.io :as io]

            [twttr.auth :as auth]
            [byte-streams :as bs]
            [manifold.deferred :as d]))

(defn parse-body
  "Parse `body` (a java.io.InputStream from an HTTP response) as JSON or a
  string, depending on the Content-Type header.

  If the Transfer-Encoding header is 'chunked', `body` is split on newlines,
  empty lines are dropped, and the rest are parsed as individual JSON documents.

  `json-options` is passed directly on to json/read(-str), after the default of
  {:key-fn keyword}, and in the non-streaming case, {:eof-error? false}."
  [body headers & json-options]
  (let [{:strs [content-type transfer-encoding]} headers]
    (if (str/starts-with? content-type "application/json")
      (if (= transfer-encoding "chunked")
        ; newline-delimited JSON
        (->> (bs/to-line-seq body)
             ; Twitter will send newlines as keep-alive signals, if the stream
             ; is sparse, "At least every 10 seconds"
             (remove empty?)
             (map (fn [line] (apply json/read-str line :key-fn keyword json-options))))
        ; single JSON document
        ; TODO: use io/reader :encoding option if supplied in content-type header
        (apply json/read (io/reader body) :key-fn keyword :eof-error? false json-options))
      ; string
      (str/trim (slurp body)))))

; The argument to middleware should be a function that takes a handler
; (which turns a request into a response), and returns a function which takes a request,
; potentially modifies that request, runs request through the given handler to get a response,
; and then returns the response, potentially after modifying it.

(defn wrap-body
  "Middleware for parsing Twitter's REST/streaming API responses, returning
  the result of `parse-body` and re-attaching the full response as metadata.

  Call (.close (:body (meta response))) to stop an infinite stream."
  [handler & json-options]
  (let [body-parser (fn body-parser [response]
                      (let [parsed-body (apply parse-body (:body response) (:headers response) json-options)]
                        (with-meta parsed-body response)))]
    (fn body-middleware-handler [request]
      (d/chain (handler request) body-parser))))

;; auth

(defn- assoc-auth-header
  "Set the 'Authorization' header in the ring request `req` as generated by
  calling auth-header on the *Credentials instance `credentials`."
  [req credentials]
  {:pre [(satisfies? auth/Credentials credentials)]}
  (let [{:keys [request-method scheme server-name uri form-params query-params]} req
        ; Generate the full URL, except query-params, for the given request.
        request-uri (str (name scheme) "://" server-name uri)
        authorization (auth/auth-header credentials request-method request-uri (merge form-params query-params))]
    (assoc-in req [:headers :Authorization] authorization)))

(defn wrap-auth
  "Middleware for providing authentication. For basic credentials, this simply
  sets the 'Authorization' header on requests. For stateful credential
  collections, it finds appropriate credentials for each request and updates
  the status on each response."
  [handler credentials]
  (condp satisfies? credentials
    auth/Credentials
    (fn auth-middleware-handler [req]
      (handler (assoc-auth-header req credentials)))
    auth/StatefulCredentials
    (fn stateful-auth-middleware-handler [req]
      (let [path (:path req)
            best-credentials (auth/find! credentials path)]
        (d/chain (handler (assoc-auth-header req best-credentials))
                 (fn [{:keys [headers] :as response}]
                   ; Update the collection of Credentials to reflect
                   ; the current state returned in the Twitter API response
                   (let [rate-limit-status (auth/headers->RateLimitStatus headers)]
                     (auth/update! credentials best-credentials path rate-limit-status))
                   response))))))
